<!doctype html>
<html>
<head>
    <title>Graderoom</title>
    <link rel="icon" href="../public/resources/common/icon.png">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:500&display=swap">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@2.8.0/dist/Chart.min.css">
    <% if (user.appearance.theme === "dark" || (user.appearance.theme === "auto" && ((user.appearance.darkModeStart < user.appearance.darkModeFinish) && ((((Date.now() / 1000 / 3600 - 8) % 24) >= user.appearance.darkModeStart) && ((Date.now() / 1000 / 3600 - 8) % 24) < user.appearance.darkModeFinish)) || ((user.appearance.darkModeStart > user.appearance.darkModeFinish) && ((((Date.now() / 1000 / 3600 - 8) % 24) >= user.appearance.darkModeStart) || ((Date.now() / 1000 / 3600 - 8) % 24) < user.appearance.darkModeFinish)))) { %>
        <link id="pageStyle" rel="stylesheet" type="text/css" href="public/css/dark_mode.css">
    <% } else { %>
        <link id="pageStyle" rel="stylesheet" type="text/css" href="public/css/light_mode.css">
    <% } %>
    <link rel="stylesheet" type="text/css" href="public/css/main.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- JavaScript Imports -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.24.0/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0/dist/Chart.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
</head>
<body>

<!-- Navbar -->
<% include partials/user/navbar.ejs %>
<% include partials/user/edit_weights_card.ejs %>

<% let page = -1; %>
<i id="pageNumber" style="display:none"><%= page %></i>

<!-- Class Links -->
<ul id="classLinks" class="mx-5 my-3 nav nav-fill" style="color: #BBBBBB;">
    <li class="nav-item" id="link-1">
        <a class="nav-link" onclick="showPage(-1)">Overview</a>
    </li>
    <% for (let i = 0; i < JSON.parse(gradeData).length; i++) { %>
        <li class="nav-item" id="link<%= i %>">
            <a style="color: <%= user.appearance.classColors[i] %>" class="nav-link"
               onclick="showPage(<%= i %>)"><%= (JSON.parse(gradeData)[i].class_name) %></a>
        </li>
    <% } %>
</ul>

<!-- Main Screen -->
<div class="container">
    <!-- Messages -->
    <div style="display: none" id="backgroundRefreshMessage"
         class="alert alert-success font-weight-bold">
        <span style="display: flex;" id="preRefresh">
            Syncing...
            <div style="float: right" class="container" id="miniLoadingDisplay">
                <div style="float: left" class="sk-chase-mini">
                    <div class="sk-chase-dot mini"></div>
                    <div class="sk-chase-dot mini"></div>
                    <div class="sk-chase-dot mini"></div>
                    <div class="sk-chase-dot mini"></div>
                    <div class="sk-chase-dot mini"></div>
                    <div class="sk-chase-dot mini"></div>
                </div>
            </div>
        </span>
        <span style="display: none;" id="refresh"> <u style="cursor: pointer"
                                                      onclick="window.reload()">Refresh</u>
             to see new updates or turn on Auto-Refresh in <u style="cursor: pointer"
                                                              onclick="$('#settingsCardDisplay').show(); openTab(4);">settings</u>.
            <a class="close" data-dismiss="alert"
               aria-label="close">X</a>
        </span>
    </div>
    <% var daysSinceUpdated = 0; %>
    <% if (user.alerts.lastUpdated.toString().toLowerCase() == ('never')) { %> <br>
    <div class="alert alert-success">
        <u style="cursor: pointer" onclick="$('#updateGradesDisplay').show(); $('#inputPassword').focus()">Sync your
            grades</u> now!
    </div>
    <% } else { %>
        <% daysSinceUpdated = Math.floor((Date.now() - user.alerts.lastUpdated) / (1000 * 3600 * 24)); %>
        <% if ((user.alerts.updateGradesReminder.toLowerCase() == ('daily') && daysSinceUpdated >= 1) || (user.alerts.updateGradesReminder.toLowerCase() == 'weekly') && daysSinceUpdated >= 7) { %>
            <div class="alert alert-danger alert-dismissible font-weight-bold">
                <a class="close" data-dismiss="alert" aria-label="close">X</a> It's been <%= daysSinceUpdated %>
                <% if (daysSinceUpdated == 1) { %>
                    day
                <% } else { %> days
                <% } %>
                since you last synced your grades! <span
                        style="float: right; display: flex"><u
                            style="cursor: pointer; margin-right: 10px"
                            onclick="$('#settingsCardDisplay').show(); openTab(4)">Alert Settings</u><u
                            style="cursor: pointer" onclick="$('#updateGradesDisplay').show()">Sync Grades</u></span>
            </div>
        <% } %>
    <% } %>

    <!-- <div class="alert alert-danger alert-dismissible" id="weightmsg" style="display:none">
        <a class="close" data-dismiss="alert" aria-label="close">X</a>
        <span id="weightmsg_text">asdf</span>
    </div> -->

    <!-- Overview Section -->
    <% if (user.alerts.lastUpdated.toString().toLowerCase() != 'never') { %>
        <span id="section-1">
            <div id="chart-container-1" class="chart-container text-center"
                 style="position: relative; height:60vh; width: 100%; margin: 0 auto;">
                    <canvas id="chart-1" class="chart" style="width:50%; margin: 0;"></canvas>
            </div>
            <br>
            <table class="table text-center" id="table-1">
                <thead><tr>
                    <% for (let i = 0; i < JSON.parse(gradeData).length; i++) { %>
                        <th style="color: <%= user.appearance.classColors[i] %>"><%= JSON.parse(gradeData)[i].class_name %></th>
                    <% } %>
                </tr></thead>
                <tbody><tr>
                    <% for (let i = 0; i < JSON.parse(gradeData).length; i++) { %>
                        <td style="color: <%= user.appearance.classColors[i] %>">
                            <div id="overviewChart<%= i %>" style="display:none; font-weight:bolder"></div>
                            <div id="weightmsgcontainer<%= i %>" style="display:none">
                                <div class="alert alert-danger font-weight-bold"
                                     id="weightmsg<%= i %>"><u style="cursor: pointer"
                                                               onclick="showUpdateWeights(<%= i %>)">Add Weights</u>
                                </div>
                            </div>
                        </td>
                    <% } %>
                </tr></tbody>
            </table>
        </span>
    <% } %>

    <!-- Class Sections -->
    <% for (let i = 0; i < JSON.parse(gradeData).length; i++) { %>
        <span id="section<%= i %>" style="display: none;">
            <div style="display:flex; align-items: center">
                <div id="chart-container<%= i %>" class="chart-container"
                     style="position: relative; height:40vh; width:100%; margin: 0 auto;">
                <canvas id="chart<%= i %>" class="chart" style="margin: auto;"></canvas>
                </div>
                <table class="table text-center" style="width: 25%; white-space: nowrap; margin: 20px"
                       id="weightsTable<%= i %>">
                <thead>
                <tr>
                    <th>Category</th>
                    <th>Weight</th>
                    <th>Points</th>
                    <th>Grade</th>
                </tr>
                </thead>

                        <tbody>
                        <% for (let j = 0; j < Object.keys(JSON.parse(weightData)[JSON.parse(gradeData)[i].class_name]).length; j++) { %>
                            <tr>
                        <td id="weightTableCategory<%= i %><%= j %>"></td>
                        <td id="weightTableWeight<%= i %><%= j %>"></td>
                        <td id="weightTablePoints<%= i %><%= j %>"></td>
                        <td id="weightTableGrade<%= i %><%= j %>"></td>
                            </tr>
                        <% } %>
                        </tbody>
                    </th>
                    <tfoot>
                <tr>
                    <th colspan="4">
                        <div style="display:none; color: <%= user.appearance.classColors[i] %>"
                             id="weightTableOverallGrade<%= i %>">

                        </div>
                        <div style="display:none" colspan="4"
                             class="alert alert-danger font-weight-bold"
                             id="weightTablemsg<%= i %>">
                        <span id="weightmsg_text<%= i %>"></span><br><u style="cursor: pointer"
                                                                        onclick="showUpdateWeights(<%= i %>)">Add Weights</u>
                    </div>
                    </th>
                </tr>
                </tfoot>
                </table>
            </div>
        <hr>
        <table class="table text-center" id="table<%= i %>">
            <thead>
            <tr>
                <th style="width:25%;">Assignment Name</th>
                <th style="width:25%;">Date</th>
                <th style="width:25%;">Category</th>
                <th style="width:25%;">Assignment Percent</th>
                <th style="width:25%;">Score</th>
            </tr>
            </thead>

            <tbody>
            <% for (let grade of JSON.parse(gradeData)[i].grades) { %>
                <tr>
                    <td><%= grade.assignment_name %> </td>
                    <td><%= grade.date %> </td>
                    <td><%= grade.category + (grade.exclude ? " (EXCLUDED) " : "") %></td>
                    <% if (grade.grade_percent == -1) { %>
                        <td></td>
                    <% } else { %>
                        <td><%= grade.grade_percent %></td>
                    <% } %>
                    <% if (grade.points_possible != 0) { %>
                        <td><%= grade.points_gotten %>/<%= grade.points_possible %></td>
                    <% } else { %>
                        <td><%= grade.points_gotten %></td>
                    <% } %>
                </tr>
            <% } %>
            </tbody>
        </table>
        </span>
    <% } %>
</div>

<!-- Custom JavaScript -->
<script>

    let user = <%- userRef %>;
    let data = <%- gradeData %>;
    let weights = <%- weightData %>
        parsedData = [];
    let unobtainedWeights = {};

    let currentPage = -1;
    let cardDisplayed = "none";
    let currentTab = 1;
    let maxTab = 4;

    let darkMode;
    let darkModeStart = user.appearance.darkModeStart || 18; // 6PM
    let darkModeFinish = user.appearance.darkModeFinish || 7; // 7AM

    let checkingTheme;

    parseData();
    setupWeightsTables();
    setupOverviewTable();
    updateWeightMessages();
    if (user.appearance.theme === "auto") {
        checkTime();
    } else if (user.appearance.theme === "dark") {
        darkMode = true;
    } else {
        darkMode = false;
    }
    let localStorage = window.localStorage;
    if (darkMode) {
        localStorage.setItem("defaultAppearance", "dark");
    } else {
        localStorage.setItem("defaultAppearance", "light");
    }
    if (localStorage.getItem("currentPage")) {
        currentPage = parseInt(localStorage.getItem("currentPage"));
    } else {
        localStorage.setItem("currentPage", currentPage);
    }
    if (user.alerts.lastUpdated !== "never") {
        renderAllCharts();
    }
    showPage(currentPage);
    if (user.schoolPassword) {
        $("#syncGradesDiv").hide();
        $("#gradeSyncDiv").show();
        checkUpdateBackground();
    } else {
        $("#gradeSyncDiv").hide();
        $("#syncGradesDiv").show();
    }
    document.getElementById("darkModeStart").setAttribute("placeholder", (darkModeStart === 0 ? "12" : darkModeStart > 12 ? (darkModeStart - 12).toString() : darkModeStart.toString()));
    document.getElementById("darkModeFinish").setAttribute("placeholder", (darkModeFinish === 24 ? "12" : darkModeFinish > 12 ? (darkModeFinish - 12).toString() : darkModeFinish.toString()));

    function setAutoTheme() {
        // console.log("Start, finish", darkModeStart, darkModeFinish);
        if (user.appearance.theme === "dark" || (user.appearance.theme === "auto" && ((darkModeStart < darkModeFinish) && ((((Date.now() / 1000 / 3600 - 8) % 24) >= darkModeStart) && ((Date.now() / 1000 / 3600 - 8) % 24) < darkModeFinish)) || ((darkModeStart > darkModeFinish) && ((((Date.now() / 1000 / 3600 - 8) % 24) >= darkModeStart) || ((Date.now() / 1000 / 3600 - 8) % 24) < darkModeFinish)))) {
            document.getElementById("pageStyle").setAttribute("href", "public/css/dark_mode.css");
            let oldDarkMode = darkMode;
            darkMode = true;
            if (darkMode !== oldDarkMode) {
                renderAllCharts();
            }
        } else {
            document.getElementById("pageStyle").setAttribute("href", "public/css/light_mode.css");
            let oldDarkMode = darkMode;
            darkMode = false;
            if (darkMode !== oldDarkMode) {
                renderAllCharts();
            }
        }
    }

    async function checkTime() {
        setAutoTheme();
        checkingTheme = window.setInterval(function () {
            setAutoTheme();
        }, 60000);
    }

    async function checkUpdateBackground() {
        $.get("/checkUpdateBackground", function (data, status) {
            if (status === "success") {
                if (data === "Sync Complete!") {
                    $("#preRefresh").hide();
                    if (user.autoRefresh) {
                        $("#backgroundRefreshMessage").hide();
                        window.reload();
                    } else {
                        $("#refresh").show();
                    }
                    clearInterval(checking);
                } else if (data === "Already Synced!") {
                    clearInterval(checking);
                } else if (data === "Did not sync") {
                    $("#backgroundRefreshMessage").show();
                    $("#weightmsg-1").hide();
                }
            }
        });
        let checking = window.setInterval(function () {
            $.get("/checkUpdateBackground", function (data, status) {
                if (status === "success") {
                    if (data === "Sync Complete!") {
                        $("#preRefresh").hide();
                        if (user.autoRefresh) {
                            $("#backgroundRefreshMessage").hide();
                            window.reload();
                        } else {
                            $("#refresh").show();
                        }
                        clearInterval(checking);
                    } else if (data === "Already Synced!") {
                        clearInterval(checking);
                    } else if (data === "Did not sync") {
                        $("#backgroundRefreshMessage").show();
                        $("#weightmsg-1").hide();
                    }
                }
            });
        }, 1000);
    }

    function getTotalWeight(classIndex) {
        let className = data[classIndex].class_name;
        let classWeights = Object.values(weights[className]);
        let totalWeight = 0;
        let classCategories = Object.keys(weights[className]);
        for (let i = 0; i < classWeights.length; i++) {
            if (getCategoryGottenAndPossible(classIndex, classCategories[i]).possible !== 0) {
                totalWeight += classWeights[i];
            }
        }
        return totalWeight;
    }

    function getOverallGrade(classIndex) {
        let className = data[classIndex].class_name;
        if (className in weights) {
            let classCategories = Object.keys(weights[className]);
            let classWeights = Object.values(weights[className]);
            let overallGrade = 0;
            for (let i = 0; i < classCategories.length; i++) {
                overallGrade += getCategoryGrade(classIndex, classCategories[i]) * classWeights[i] / 100;
            }
            let ratio = 100 / getTotalWeight(classIndex);
            overallGrade *= ratio;
            return overallGrade;
        }
        return 0;
    }

    function getLetterGrade(grade) {
        if (grade >= 97.5) {
            return "A+";
        } else if (grade >= 92.5) {
            return "A";
        } else if (grade >= 89.5) {
            return "A-";
        } else if (grade >= 87.5) {
            return "B+";
        } else if (grade >= 82.5) {
            return "B";
        } else if (grade >= 79.5) {
            return "B-";
        } else if (grade >= 77.5) {
            return "C+";
        } else if (grade >= 72.5) {
            return "C";
        } else if (grade >= 69.5) {
            return "C-";
        } else if (grade >= 67.5) {
            return "D+";
        } else if (grade >= 62.5) {
            return "D";
        } else if (grade >= 59.5) {
            return "D-";
        }
        return "F";
    }

    function setupWeightsTables() {
        for (let i = 0; i < data.length; i++) {
            let className = data[i].class_name;
            if (weights[className]) {
                let tableCategories = Object.keys(weights[className]);
                let tableWeights = Object.values(weights[className]);
                for (let j = 0; j < tableCategories.length; j++) {
                    document.getElementById("weightTableCategory" + i + j).textContent = tableCategories[j];
                    document.getElementById("weightTableWeight" + i + j).textContent = tableWeights[j] + "%";
                    let categoryGottenAndPossible = getCategoryGottenAndPossible(i, tableCategories[j]);
                    document.getElementById("weightTablePoints" + i + j).textContent = +(categoryGottenAndPossible.gotten.toFixed(3)) + ((categoryGottenAndPossible.possible !== 0) ? ("/" + +(categoryGottenAndPossible.possible.toFixed(3))) : "");
                    let categoryGrade = getCategoryGrade(i, tableCategories[j]);
                    if (categoryGottenAndPossible.possible !== 0) {
                        document.getElementById("weightTableGrade" + i + j).textContent = categoryGrade + "% (" + getLetterGrade(categoryGrade) + ")";
                    }
                }
                let overallGrade = getOverallGrade(i);
                document.getElementById("weightTableOverallGrade" + i).textContent = (+(overallGrade.toFixed(3))).toString() + "% (" + getLetterGrade(overallGrade) + ")";
            }
            if (!unobtainedWeights[className]) {
                document.getElementById("weightTableOverallGrade" + i).style.display = "block";
            } else {
                document.getElementById("weightTablemsg" + i).style.display = "block";
            }
        }
    }

    function setupOverviewTable() {
        for (let i = 0; i < data.length; i++) {
            let className = data[i].class_name;
            if (!unobtainedWeights[className]) {
                document.getElementById("overviewChart" + i).style.display = "block";
                let overallGrade = getOverallGrade(i);
                document.getElementById("overviewChart" + i).innerHTML = (+(overallGrade.toFixed(2))).toString() + "% </br>" + getLetterGrade(overallGrade);
            } else {
                document.getElementById("weightmsgcontainer" + i).style.display = "block";
            }
        }
    }

    function getCategoryGottenAndPossible(classIndex, categoryName) {
        let grades = data[classIndex].grades;
        let totalGotten = 0;
        let totalPossible = 0;
        for (let i = 0; i < grades.length; i++) {
            if (!grades[i].exclude && grades[i].category === categoryName) {
                totalGotten += grades[i].points_gotten;
                totalPossible += grades[i].points_possible;
            }
        }
        return {"gotten": totalGotten, "possible": totalPossible};
    }

    function getCategoryGrade(classIndex, categoryName) {
        let categoryGottenAndPossible = getCategoryGottenAndPossible(classIndex, categoryName);
        let totalGotten = categoryGottenAndPossible.gotten;
        let totalPossible = categoryGottenAndPossible.possible;
        if (totalPossible === 0) {
            return 0;
        }
        return +((totalGotten / totalPossible * 100).toFixed(3));
    }

    function showWeightMessage(msg, id) {
        let wmRef = document.getElementById("weightmsg" + id);
        let wmTextRef = document.getElementById("weightmsg_text" + id);
        wmRef.style.display = "block";
        wmTextRef.innerText = msg;
    }

    function hideWeightMessage(id) {
        let wmRef = document.getElementById("weightmsg" + id);
        let wmTextRef = document.getElementById("weightmsg_text" + id);
        wmRef.style.display = "none";
        wmTextRef.innerText = "";
    }

    function updateWeightMessages() {
        for (let id = 0; id < data.length; id++) {
            if (data[id].class_name in unobtainedWeights) { //TODO idk if this index get is safe
                showWeightMessage("Missing Weights: " + unobtainedWeights[data[id].class_name].join(", "), id);
            }
        }
    }

    function parseData() {

        /*
         WEIGHTS first
         */

        for (let classData of data) {
            let className = classData.class_name;
            let needWeights = !(className in weights) || (Object.entries(weights[className]).length === 0 && weights[className].constructor === Object);
            let localMissingCategories = [];

            if ((className in weights) && (weights[className].length)) {
                needWeights = false;
            } else {
                for (let grade of classData.grades) {
                    // console.log(grade.category)

                    if (!(grade.category in weights[className])) {
                        if (!localMissingCategories.includes(grade.category)) {
                            localMissingCategories.push(grade.category);
                        }
                        needWeights = true;
                    }

                    if (localMissingCategories.length <=1) // Not need weights if only one weight   
                        needWeights = false;
                    // console.log("LMC")
                    // console.log(localMissingCategories)
                }
                // console.log("LMC")
                // console.log(localMissingCategories)

                if (needWeights) {
                    unobtainedWeights[className] = localMissingCategories; //todo here add specific weights (i.e. You don't have the Test category...)
                }
            }
        }

        /**
         * now grades!
         */

        //Add array to each object in parsedData: one for weights (not needed?), one for missing weights
        //Get data for one class

        for (let classData of data) {

            let className = classData.class_name;
            let overallGradeSteps = [];
            let totalPossiblesAndGottens = {}; //by category
            let totalWeightValue = 0; // divide by the total weight amount - so even if the final is not entered the grade is still of of 100
            // VERY JANK CHANGE LATER
            let doesntHaveWeights = className in unobtainedWeights; //Already checked for above: || weights[className].hasWeights === false;
            // console.log(className + " DHW? : " + doesntHaveWeights);

            for (let grade of classData.grades) {
                let category = grade.category;
                if (doesntHaveWeights) {
                    category = "default";
                }
                try {
                    if (typeof totalPossiblesAndGottens[category] === "undefined") {
                        let weightVal = 100;
                        if (!doesntHaveWeights) {
                            weightVal = weights[className][category];
                        }
                        totalPossiblesAndGottens[category] = {
                            totalPossible: 0, totalGotten: 0, weight: weightVal
                        };
                        totalWeightValue += weightVal;
                    }

                    if (!grade.exclude) {
                        totalPossiblesAndGottens[category].totalPossible += grade.points_possible;
                        totalPossiblesAndGottens[category].totalGotten += grade.points_gotten;
                    }

                    let overallPercent = 0;
                    for (let [key, value] of Object.entries(totalPossiblesAndGottens)) {
                        overallPercent = overallPercent + (value.weight * (value.totalPossible !== 0 ? (value.totalGotten / value.totalPossible) : value.totalGotten));
                    }
                    let total = ((overallPercent / totalWeightValue) * 100).toFixed(3);
                    total = +total;
                    //rounds to 3 decimal places (the plus sign drops any trailing zeros)

                    overallGradeSteps.push(total);
                } catch (err) {
                    console.log(err);
                    console.log("bad weight input");
                }
            }

            let assignmentNames = classData.grades.map(x => x.assignment_name);
            let assignmentTimestamps = classData.grades.map(x => new Date(x.date));
            let assignmentPercents = classData.grades.map(x => x.grade_percent);
            let assignmentScoresParsed = classData.grades.map(x => x.points_gotten + "/" + x.points_possible);
            let assignmentCategories = classData.grades.map(x => x.category);
            let assignmentExcluded = classData.grades.map(x => x.exclude);
            let mixedData = overallGradeSteps.map(function (grade, i) {
                return {x: assignmentTimestamps[i], y: grade};
            });

            parsedData.push({
                                assignmentNames: assignmentNames,
                                assignmentTimestamps: assignmentTimestamps,
                                assignmentPercents: assignmentPercents,
                                assignmentScoresParsed: assignmentScoresParsed,
                                assignmentCategories: assignmentCategories,
                                assignmentExcluded: assignmentExcluded,
                                mixedData: mixedData
                            });
        }
    }

    function renderAllCharts() {
        try {
            renderOverviewChart();
            for (let i = 0; i < data.length; i++) {
                renderChart(i);
            }
        } catch {
        }
    }

    let hoveredDatasetIndex = -1;

    function renderOverviewChart() {
        let ctx = document.getElementById("chart-1");
        let id = 0;
        let dataset = [];
        let colors = user.appearance.classColors;
        for (let i = 0; i < data.length; i++) {
            dataset.push({
                             label: data[i].class_name,
                             backgroundColor: "transparent",
                             pointBackgroundColor: colors[i],
                             pointBorderColor: "transparent",
                             borderColor: colors[i],
                             data: parsedData[i].mixedData,
                             cubicInterpolationMode: "monotone",
                             spanGaps: false,
                             pointRadius: 3,
                             borderWidth: 3,
                             pointHoverRadius: 7,
                             pointHoverBackgroundColor: colors[i],
                             pointHoverBorderColor: colors[i],
                             pointHoverBorderWidth: 2
                         });
        }
        let numRunning = 0;
        let myChart = new Chart(ctx, {
            type: "line", data: {
                datasets: dataset
            }, options: {
                hover: {
                    mode: "nearest", intersect: false
                }, onHover: function onHover(evt, activeElements) {
                    if (!activeElements || !activeElements.length) {
                        return;
                    }
                    let datasetIndex = activeElements[0]._datasetIndex;
                    let activeDataset = this.data.datasets[datasetIndex];
                    for (let i = 0; i < this.data.datasets.length; i++) {
                        let inactiveDataset = this.data.datasets[i];
                        inactiveDataset.borderWidth = 3;
                        inactiveDataset.pointRadius = 3;
                    }
                    activeDataset.borderWidth = 5;
                    activeDataset.pointRadius = 5;
                    this.update(200);
                    let chart = this;
                    numRunning++;
                    setTimeout(function () {
                        numRunning--;
                        if (numRunning === 0) {
                            for (let i = 0; i < chart.data.datasets.length; i++) {
                                let dataset = chart.data.datasets[i];
                                dataset.borderWidth = 3;
                                dataset.pointRadius = 3;
                            }
                            chart.update(2000);
                        }

                    }, 6000);
                }, scales: {
                    xAxes: [{
                        type: "time", time: {
                            unit: "month"
                        }, ticks: {
                            fontColor: (darkMode ? "white" : "black"), fontFamily: "Verdana", fontSize: "13"
                        }, gridLines: {
                            color: "#555555"
                        }
                    }], yAxes: [{
                        ticks: {
                            fontColor: (darkMode ? "white" : "black"), fontFamily: "Verdana", fontSize: "12"
                        }, gridLines: {
                            color: "#555555", drawBorder: false
                        }
                    }]
                }, animation: {
                    easing: "easeOutCubic"
                }, legend: {
                    display: true, position: "top", labels: {
                        fontColor: (darkMode ? "white" : "black"), fontFamily: "Verdana", boxWidth: 20, fontSize: 13
                    }
                }, tooltips: {
                    enabled: true, position: "nearest", intersect: false, displayColors: true, callbacks: {
                        title: function (tooltipItems, data) {
                            return moment(tooltipItems[0].xLabel).format("MM/DD/YY") + " " + parseFloat(tooltipItems[0].value).toFixed(2) + "%";
                        }, label: function (tooltipItem, data) {
                            return ["[" + parsedData[tooltipItem.datasetIndex].assignmentCategories[tooltipItem.index] + "] " + (parsedData[tooltipItem.datasetIndex].assignmentExcluded[tooltipItem.index] ? "[EXCLUDED] " : "") + parsedData[tooltipItem.datasetIndex].assignmentNames[tooltipItem.index] + " - " + (parsedData[tooltipItem.datasetIndex].assignmentPercents[tooltipItem.index] !== -1 ? (parsedData[tooltipItem.datasetIndex].assignmentPercents[tooltipItem.index] + "%") : ("")) + ((parsedData[tooltipItem.datasetIndex].assignmentScoresParsed[tooltipItem.index].substring(parsedData[tooltipItem.datasetIndex].assignmentScoresParsed[tooltipItem.index].length - 2)) !== "/0" ? (" (" + parsedData[tooltipItem.datasetIndex].assignmentScoresParsed[tooltipItem.index] + ")") : (parsedData[tooltipItem.datasetIndex].assignmentScoresParsed[tooltipItem.index].substring(0, parsedData[tooltipItem.datasetIndex].assignmentScoresParsed[tooltipItem.index].length - 2)))];
                        }
                    }
                }, responsive: true, maintainAspectRatio: false
            }
        });
    }

    function renderChart(id) {
        let ctx = document.getElementById("chart" + id);
        let colors = user.appearance.classColors;
        let myChart = new Chart(ctx, {
            type: "line", data: {
                datasets: [{
                    label: "parsedData[id]",
                    backgroundColor: "rgba(256,256,256,0.05)",
                    pointBackgroundColor: colors[id],
                    pointBorderColor: colors[id],
                    borderColor: colors[id],
                    fill: "start",
                    data: parsedData[id].mixedData,
                    cubicInterpolationMode: "monotone",
                    spanGaps: false,
                    pointRadius: 3,
                    borderWidth: 3,
                    pointHoverRadius: 7,
                    pointHoverBackgroundColor: colors[id],
                    pointHoverBorderColor: colors[id],
                    pointHoverBorderWidth: 2
                }]
            }, options: {
                hover: {
                    mode: "nearest", intersect: false
                }, scales: {
                    xAxes: [{
                        type: "time", time: {
                            unit: "month"
                        }, ticks: {
                            fontColor: (darkMode ? "white" : "black"), fontFamily: "Verdana", fontSize: "13"
                        }, gridLines: {
                            color: "#555555"
                        }
                    }], yAxes: [{
                        ticks: {
                            fontColor: (darkMode ? "white" : "black"), fontFamily: "Verdana", fontSize: "12"
                        }, gridLines: {
                            color: "#555555", drawBorder: false
                        }
                    }]
                }, animation: {
                    easing: "easeOutCubic"
                }, legend: {
                    display: false
                }, tooltips: {
                    enabled: true, position: "nearest", intersect: false, displayColors: false, callbacks: {
                        title: function (tooltipItems, data) {
                            return moment(tooltipItems[0].xLabel).format("MM/DD/YY") + " " + parseFloat(tooltipItems[0].value).toFixed(2) + "%";
                        }, label: function (tooltipItem, data) {
                            return ["[" + parsedData[id].assignmentCategories[tooltipItem.index] + "] " + (parsedData[tooltipItem.datasetIndex].assignmentExcluded[tooltipItem.index] ? "[EXCLUDED]" : "") + parsedData[id].assignmentNames[tooltipItem.index] + " - " + (parsedData[id].assignmentPercents[tooltipItem.index] !== -1 ? (parsedData[id].assignmentPercents[tooltipItem.index] + "%") : ("")) + ((parsedData[id].assignmentScoresParsed[tooltipItem.index].substring(parsedData[id].assignmentScoresParsed[tooltipItem.index].length - 2)) !== "/0" ? (" (" + parsedData[id].assignmentScoresParsed[tooltipItem.index] + ")") : (parsedData[id].assignmentScoresParsed[tooltipItem.index].substring(0, parsedData[id].assignmentScoresParsed[tooltipItem.index].length - 2)))];
                        }
                    }
                }, responsive: true, maintainAspectRatio: false
            }
        });
    }

    function showPage(id) {
        if (id === -1) {
            renderOverviewChart();
        } else {
            renderChart(id);
        }
        document.getElementById("pageNumber").textContent = id;
        for (let i = -1; i < data.length; i++) {
            document.getElementById("link" + i).classList.remove("active");
        }
        document.getElementById("link" + id).classList.add("active");

        for (let i = -1; i < data.length; i++) {
            document.getElementById("section" + i).style.display = "none";
        }
        document.getElementById("section" + id).style.display = "block";

        window.localStorage.setItem("currentPage", id);
        currentPage = id;
    }

    document.onkeydown = function (e) {

        e = e || window.event;

        if (e.keyCode === 38) {
            // up arrow
        } else if (e.keyCode === 40) {
            // down arrow
        } else if (e.keyCode === 37) {
            // left arrow
            if ($("#settingsCardDisplay").css("display") === "block") {
                if (currentTab === 1) {
                    openTab(maxTab);
                } else {
                    openTab(currentTab - 1);
                }
            } else if ($("#updateGradesDisplay").css("display") === "block") {
            } else if ($("#updateWeightsDisplay").css("display") === "block") {
            } else {
                if (currentPage === -1) {
                    showPage(data.length - 1);
                } else {
                    showPage(currentPage - 1);
                }
            }
        } else if (e.keyCode === 39) {
            // right arrow
            if ($("#settingsCardDisplay").css("display") === "block") {
                if (currentTab === maxTab) {
                    openTab(1);
                } else {
                    openTab(currentTab + 1);
                }
            } else if ($("#updateGradesDisplay").css("display") === "block") {
            } else if ($("#updateWeightsDisplay").css("display") === "block") {
            } else {
                if (currentPage === data.length - 1) {
                    showPage(-1);
                } else {
                    showPage(currentPage + 1);
                }
            }
        } else if (e.keyCode === 83) {
            if ($("#settingsCardDisplay").css("display") === "block") {
                closeForm("settingsCardDisplay");
            } else if ($("#updateGradesDisplay").css("display") === "block") {
            } else if ($("#updateWeightsDisplay").css("display") === "block") {
            } else {
                $("#settingsCardDisplay").show();
            }
        } else {
            //console.log(e.keyCode);
        }

    };

</script>
</body>
</html>
